import { Injectable, Optional, Inject } from '@angular/core';
import { NavigationStart, NavigationEnd, NavigationCancel, NavigationError } from '@angular/router';
import { of } from 'rxjs';
import { tap, delay, switchMap, filter } from 'rxjs/operators';
import { NG_PROGRESS_ROUTER_CONFIG } from './ng-progress-router.interface';
import * as i0 from "@angular/core";
import * as i1 from "ngx-progressbar";
import * as i2 from "@angular/router";
/**
 * Check if a router event type exists in an array of router event types
 */
function eventExists(routerEvent, events) {
    let res = false;
    events.map((event) => res = res || routerEvent instanceof event);
    return res;
}
export class NgProgressRouter {
    constructor(progress, router, config) {
        this._config = {
            id: 'root',
            delay: 0,
            startEvents: [NavigationStart],
            completeEvents: [NavigationEnd, NavigationCancel, NavigationError]
        };
        this._config = config ? { ...this._config, ...config } : this._config;
        const progressRef = progress.ref(this._config.id);
        const startProgress = of({}).pipe(tap(() => progressRef.start()));
        const completeProgress = of({}).pipe(delay(this._config.delay), tap(() => progressRef.complete()));
        const filterEvents = [...this._config.startEvents, ...this._config.completeEvents];
        router.events.pipe(filter((event) => eventExists(event, filterEvents)), switchMap((event) => eventExists(event, this._config.startEvents) ? startProgress : completeProgress)).subscribe();
    }
}
NgProgressRouter.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: NgProgressRouter, deps: [{ token: i1.NgProgress }, { token: i2.Router }, { token: NG_PROGRESS_ROUTER_CONFIG, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
NgProgressRouter.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: NgProgressRouter, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: NgProgressRouter, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return [{ type: i1.NgProgress }, { type: i2.Router }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [NG_PROGRESS_ROUTER_CONFIG]
                }] }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmctcHJvZ3Jlc3Mtcm91dGVyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtcHJvZ3Jlc3NiYXIvcm91dGVyL3NyYy9uZy1wcm9ncmVzcy1yb3V0ZXIuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQVEsTUFBTSxlQUFlLENBQUM7QUFDbkUsT0FBTyxFQUFVLGVBQWUsRUFBRSxhQUFhLEVBQUUsZ0JBQWdCLEVBQUUsZUFBZSxFQUFzQixNQUFNLGlCQUFpQixDQUFDO0FBQ2hJLE9BQU8sRUFBRSxFQUFFLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDMUIsT0FBTyxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRS9ELE9BQU8sRUFBZ0QseUJBQXlCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQzs7OztBQUV6SDs7R0FFRztBQUNILFNBQVMsV0FBVyxDQUFDLFdBQWtCLEVBQUUsTUFBMkI7SUFDbEUsSUFBSSxHQUFHLEdBQUcsS0FBSyxDQUFDO0lBQ2hCLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUF3QixFQUFFLEVBQUUsQ0FBQyxHQUFHLEdBQUcsR0FBRyxJQUFJLFdBQVcsWUFBWSxLQUFLLENBQUMsQ0FBQztJQUNwRixPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUM7QUFLRCxNQUFNLE9BQU8sZ0JBQWdCO0lBUTNCLFlBQVksUUFBb0IsRUFBRSxNQUFjLEVBQWlELE1BQThCO1FBUDlHLFlBQU8sR0FBeUI7WUFDL0MsRUFBRSxFQUFFLE1BQU07WUFDVixLQUFLLEVBQUUsQ0FBQztZQUNSLFdBQVcsRUFBRSxDQUFDLGVBQWUsQ0FBQztZQUM5QixjQUFjLEVBQUUsQ0FBQyxhQUFhLEVBQUUsZ0JBQWdCLEVBQUUsZUFBZSxDQUFDO1NBQ25FLENBQUM7UUFHQSxJQUFJLENBQUMsT0FBTyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBQyxHQUFHLElBQUksQ0FBQyxPQUFPLEVBQUUsR0FBRyxNQUFNLEVBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQztRQUNwRSxNQUFNLFdBQVcsR0FBa0IsUUFBUSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRWpFLE1BQU0sYUFBYSxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQy9CLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxXQUFXLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FDL0IsQ0FBQztRQUVGLE1BQU0sZ0JBQWdCLEdBQUcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FDbEMsS0FBSyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQ3pCLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxXQUFXLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FDbEMsQ0FBQztRQUVGLE1BQU0sWUFBWSxHQUF3QixDQUFDLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUUsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBRXhHLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUNoQixNQUFNLENBQUMsQ0FBQyxLQUFZLEVBQUUsRUFBRSxDQUFDLFdBQVcsQ0FBQyxLQUFLLEVBQUUsWUFBWSxDQUFDLENBQUMsRUFDMUQsU0FBUyxDQUFDLENBQUMsS0FBWSxFQUFFLEVBQUUsQ0FBQyxXQUFXLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsZ0JBQWdCLENBQUMsQ0FDN0csQ0FBQyxTQUFTLEVBQUUsQ0FBQztJQUNoQixDQUFDOzs2R0EzQlUsZ0JBQWdCLGtFQVEyQyx5QkFBeUI7aUhBUnBGLGdCQUFnQixjQUZmLE1BQU07MkZBRVAsZ0JBQWdCO2tCQUg1QixVQUFVO21CQUFDO29CQUNWLFVBQVUsRUFBRSxNQUFNO2lCQUNuQjs7MEJBU29ELFFBQVE7OzBCQUFJLE1BQU07MkJBQUMseUJBQXlCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgT3B0aW9uYWwsIEluamVjdCwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBSb3V0ZXIsIE5hdmlnYXRpb25TdGFydCwgTmF2aWdhdGlvbkVuZCwgTmF2aWdhdGlvbkNhbmNlbCwgTmF2aWdhdGlvbkVycm9yLCBSb3V0ZXJFdmVudCwgRXZlbnQgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xyXG5pbXBvcnQgeyBvZiB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyB0YXAsIGRlbGF5LCBzd2l0Y2hNYXAsIGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuaW1wb3J0IHsgTmdQcm9ncmVzcywgTmdQcm9ncmVzc1JlZiB9IGZyb20gJ25neC1wcm9ncmVzc2Jhcic7XHJcbmltcG9ydCB7IE5nUHJvZ3Jlc3NSb3V0ZXJDb25maWcsIFByb2dyZXNzUm91dGVyQ29uZmlnLCBOR19QUk9HUkVTU19ST1VURVJfQ09ORklHIH0gZnJvbSAnLi9uZy1wcm9ncmVzcy1yb3V0ZXIuaW50ZXJmYWNlJztcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhIHJvdXRlciBldmVudCB0eXBlIGV4aXN0cyBpbiBhbiBhcnJheSBvZiByb3V0ZXIgZXZlbnQgdHlwZXNcclxuICovXHJcbmZ1bmN0aW9uIGV2ZW50RXhpc3RzKHJvdXRlckV2ZW50OiBFdmVudCwgZXZlbnRzOiBUeXBlPFJvdXRlckV2ZW50PltdKTogYm9vbGVhbiB7XHJcbiAgbGV0IHJlcyA9IGZhbHNlO1xyXG4gIGV2ZW50cy5tYXAoKGV2ZW50OiBUeXBlPFJvdXRlckV2ZW50PikgPT4gcmVzID0gcmVzIHx8IHJvdXRlckV2ZW50IGluc3RhbmNlb2YgZXZlbnQpO1xyXG4gIHJldHVybiByZXM7XHJcbn1cclxuXHJcbkBJbmplY3RhYmxlKHtcclxuICBwcm92aWRlZEluOiAncm9vdCdcclxufSlcclxuZXhwb3J0IGNsYXNzIE5nUHJvZ3Jlc3NSb3V0ZXIge1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgX2NvbmZpZzogUHJvZ3Jlc3NSb3V0ZXJDb25maWcgPSB7XHJcbiAgICBpZDogJ3Jvb3QnLFxyXG4gICAgZGVsYXk6IDAsXHJcbiAgICBzdGFydEV2ZW50czogW05hdmlnYXRpb25TdGFydF0sXHJcbiAgICBjb21wbGV0ZUV2ZW50czogW05hdmlnYXRpb25FbmQsIE5hdmlnYXRpb25DYW5jZWwsIE5hdmlnYXRpb25FcnJvcl1cclxuICB9O1xyXG5cclxuICBjb25zdHJ1Y3Rvcihwcm9ncmVzczogTmdQcm9ncmVzcywgcm91dGVyOiBSb3V0ZXIsIEBPcHRpb25hbCgpIEBJbmplY3QoTkdfUFJPR1JFU1NfUk9VVEVSX0NPTkZJRykgY29uZmlnOiBOZ1Byb2dyZXNzUm91dGVyQ29uZmlnKSB7XHJcbiAgICB0aGlzLl9jb25maWcgPSBjb25maWcgPyB7Li4udGhpcy5fY29uZmlnLCAuLi5jb25maWd9IDogdGhpcy5fY29uZmlnO1xyXG4gICAgY29uc3QgcHJvZ3Jlc3NSZWY6IE5nUHJvZ3Jlc3NSZWYgPSBwcm9ncmVzcy5yZWYodGhpcy5fY29uZmlnLmlkKTtcclxuXHJcbiAgICBjb25zdCBzdGFydFByb2dyZXNzID0gb2Yoe30pLnBpcGUoXHJcbiAgICAgIHRhcCgoKSA9PiBwcm9ncmVzc1JlZi5zdGFydCgpKVxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBjb21wbGV0ZVByb2dyZXNzID0gb2Yoe30pLnBpcGUoXHJcbiAgICAgIGRlbGF5KHRoaXMuX2NvbmZpZy5kZWxheSksXHJcbiAgICAgIHRhcCgoKSA9PiBwcm9ncmVzc1JlZi5jb21wbGV0ZSgpKVxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBmaWx0ZXJFdmVudHM6IFR5cGU8Um91dGVyRXZlbnQ+W10gPSBbLi4udGhpcy5fY29uZmlnLnN0YXJ0RXZlbnRzLCAuLi50aGlzLl9jb25maWcuY29tcGxldGVFdmVudHNdO1xyXG5cclxuICAgIHJvdXRlci5ldmVudHMucGlwZShcclxuICAgICAgZmlsdGVyKChldmVudDogRXZlbnQpID0+IGV2ZW50RXhpc3RzKGV2ZW50LCBmaWx0ZXJFdmVudHMpKSxcclxuICAgICAgc3dpdGNoTWFwKChldmVudDogRXZlbnQpID0+IGV2ZW50RXhpc3RzKGV2ZW50LCB0aGlzLl9jb25maWcuc3RhcnRFdmVudHMpID8gc3RhcnRQcm9ncmVzcyA6IGNvbXBsZXRlUHJvZ3Jlc3MpXHJcbiAgICApLnN1YnNjcmliZSgpO1xyXG4gIH1cclxufVxyXG4iXX0=