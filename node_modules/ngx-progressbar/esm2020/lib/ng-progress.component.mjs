import { Component, Input, Output, EventEmitter, ChangeDetectionStrategy } from '@angular/core';
import { map } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "./ng-progress.service";
import * as i2 from "@angular/common";
export class NgProgressComponent {
    constructor(_ngProgress) {
        this._ngProgress = _ngProgress;
        /** Creates a new instance if id is not already exists */
        this.id = 'root';
        /** Initializes inputs from the global config */
        this.min = this._ngProgress.config.min;
        this.max = this._ngProgress.config.max;
        this.ease = this._ngProgress.config.ease;
        this.color = this._ngProgress.config.color;
        this.speed = this._ngProgress.config.speed;
        this.thick = this._ngProgress.config.thick;
        this.fixed = this._ngProgress.config.fixed;
        this.meteor = this._ngProgress.config.meteor;
        this.spinner = this._ngProgress.config.spinner;
        this.trickleSpeed = this._ngProgress.config.trickleSpeed;
        this.debounceTime = this._ngProgress.config.debounceTime;
        this.trickleFunc = this._ngProgress.config.trickleFunc;
        this.spinnerPosition = this._ngProgress.config.spinnerPosition;
        this.direction = this._ngProgress.config.direction;
        this.started = new EventEmitter();
        this.completed = new EventEmitter();
    }
    get isStarted() {
        return this.progressRef?.isStarted;
    }
    ngOnChanges() {
        // Update progress bar config when inputs change
        this.progressRef?.setConfig({
            max: (this.max > 0 && this.max <= 100) ? this.max : 100,
            min: (this.min < 100 && this.min >= 0) ? this.min : 0,
            speed: this.speed,
            trickleSpeed: this.trickleSpeed,
            trickleFunc: this.trickleFunc,
            debounceTime: this.debounceTime
        });
    }
    ngOnInit() {
        // Get progress bar service instance
        this.progressRef = this._ngProgress.ref(this.id, {
            max: this.max,
            min: this.min,
            speed: this.speed,
            trickleSpeed: this.trickleSpeed,
            debounceTime: this.debounceTime
        });
        // Subscribe to progress state
        this.state$ = this.progressRef.state.pipe(map((state) => ({
            active: state.active,
            transform: `translate3d(${state.value}%,0,0)`
        })));
        // Subscribes to started and completed events on demand
        if (this.started.observed) {
            this._started = this.progressRef.started.subscribe(() => this.started.emit());
        }
        if (this.completed.observed) {
            this._completed = this.progressRef.completed.subscribe(() => this.completed.emit());
        }
    }
    ngOnDestroy() {
        this._started?.unsubscribe();
        this._completed?.unsubscribe();
        this.progressRef?.destroy();
    }
    start() {
        this.progressRef.start();
    }
    complete() {
        this.progressRef.complete();
    }
    inc(n) {
        this.progressRef.inc(n);
    }
    set(n) {
        this.progressRef.set(n);
    }
}
NgProgressComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: NgProgressComponent, deps: [{ token: i1.NgProgress }], target: i0.ɵɵFactoryTarget.Component });
NgProgressComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.0.0", type: NgProgressComponent, selector: "ng-progress", inputs: { id: "id", min: "min", max: "max", ease: "ease", color: "color", speed: "speed", thick: "thick", fixed: "fixed", meteor: "meteor", spinner: "spinner", trickleSpeed: "trickleSpeed", debounceTime: "debounceTime", trickleFunc: "trickleFunc", spinnerPosition: "spinnerPosition", direction: "direction" }, outputs: { started: "started", completed: "completed" }, host: { attributes: { "role": "progressbar" }, properties: { "attr.spinnerPosition": "spinnerPosition", "attr.direction": "direction", "attr.thick": "thick", "attr.fixed": "fixed" } }, usesOnChanges: true, ngImport: i0, template: `
    <ng-container *ngIf="state$ | async; let state">
      <div class="ng-progress-bar"
           [attr.active]="state.active"
           [style.transition]="'opacity ' + speed + 'ms ' + ease">
        <div class="ng-bar-placeholder">
          <div class="ng-bar"
               [style.transform]="state.transform"
               [style.backgroundColor]="color"
               [style.transition]="state.active ? 'all ' + speed + 'ms ' + ease : 'none'">
            <div *ngIf="meteor" class="ng-meteor" [style.boxShadow]="'0 0 10px '+ color + ', 0 0 5px ' + color"></div>
          </div>
        </div>
        <div *ngIf="spinner" class="ng-spinner">
          <div class="ng-spinner-icon"
               [style.borderTopColor]="color"
               [style.borderLeftColor]="color"></div>
        </div>
      </div>
    </ng-container>
  `, isInline: true, styles: [":host{z-index:999999;pointer-events:none}:host[fixed=true] .ng-progress-bar,:host[fixed=true] .ng-spinner{position:fixed}:host[fixed=true] .ng-spinner{top:15px}:host[fixed=true][spinnerPosition=left] .ng-spinner{left:15px}:host[fixed=true][spinnerPosition=right] .ng-spinner{right:15px}:host[thick=true] .ng-spinner-icon{width:24px;height:24px;border-width:3px}:host[thick=true] .ng-bar-placeholder{height:3px!important}:host[direction=\"ltr+\"] .ng-meteor,:host[direction=ltr-] .ng-meteor{transform:rotate(3deg)}:host[direction=\"ltr+\"][thick=true] .ng-meteor,:host[direction=ltr-][thick=true] .ng-meteor{transform:rotate(4deg)}:host[direction=\"ltr+\"] .ng-bar,:host[direction=\"rtl+\"] .ng-bar{margin-left:-100%}:host[direction=\"ltr+\"] .ng-meteor,:host[direction=\"rtl+\"] .ng-meteor{right:0}:host[direction=\"ltr+\"] .ng-meteor,:host[direction=rtl-] .ng-meteor{top:-3px}:host[direction=\"ltr+\"][thick=true] .ng-meteor,:host[direction=rtl-][thick=true] .ng-meteor{top:-4px}:host[direction=ltr-] .ng-meteor,:host[direction=\"rtl+\"] .ng-meteor{bottom:-3px}:host[direction=ltr-][thick=true] .ng-meteor,:host[direction=\"rtl+\"][thick=true] .ng-meteor{bottom:-4px}:host[direction=ltr-] .ng-bar-placeholder,:host[direction=\"rtl+\"] .ng-bar-placeholder{transform:rotate(180deg)}:host[direction=ltr-] .ng-spinner-icon,:host[direction=\"rtl+\"] .ng-spinner-icon{animation-directionection:reverse}:host[direction=\"rtl+\"] .ng-meteor,:host[direction=rtl-] .ng-meteor{transform:rotate(-3deg)}:host[direction=\"rtl+\"][thick=true] .ng-meteor,:host[direction=rtl-][thick=true] .ng-meteor{transform:rotate(-4deg)}:host[spinnerPosition=left] .ng-spinner{left:10px}:host[spinnerPosition=right] .ng-spinner{right:10px}.ng-progress-bar{position:relative;z-index:999999;top:0;left:0;width:100%;transform:scale(1);filter:alpha(opacity=0);opacity:0}.ng-progress-bar[active=true]{filter:alpha(opacity=100);opacity:1;transition:none}.ng-bar-placeholder{position:absolute;height:2px;width:100%}.ng-bar{width:100%;height:100%;transform:translate(-100%,0,0)}.ng-meteor{display:block;position:absolute;width:100px;height:100%;opacity:1}.ng-spinner{position:absolute;display:block;z-index:1031;top:10px}.ng-spinner-icon{width:18px;height:18px;box-sizing:border-box;-webkit-animation:spinner-animation .25s linear infinite;animation:spinner-animation .25s linear infinite;border:2px solid transparent;border-radius:50%}@-webkit-keyframes spinner-animation{0%{transform:rotate(0)}to{transform:rotate(360deg)}}@keyframes spinner-animation{0%{transform:rotate(0)}to{transform:rotate(360deg)}}\n"], dependencies: [{ kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "pipe", type: i2.AsyncPipe, name: "async" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: NgProgressComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ng-progress', host: {
                        'role': 'progressbar',
                        '[attr.spinnerPosition]': 'spinnerPosition',
                        '[attr.direction]': 'direction',
                        '[attr.thick]': 'thick',
                        '[attr.fixed]': 'fixed'
                    }, template: `
    <ng-container *ngIf="state$ | async; let state">
      <div class="ng-progress-bar"
           [attr.active]="state.active"
           [style.transition]="'opacity ' + speed + 'ms ' + ease">
        <div class="ng-bar-placeholder">
          <div class="ng-bar"
               [style.transform]="state.transform"
               [style.backgroundColor]="color"
               [style.transition]="state.active ? 'all ' + speed + 'ms ' + ease : 'none'">
            <div *ngIf="meteor" class="ng-meteor" [style.boxShadow]="'0 0 10px '+ color + ', 0 0 5px ' + color"></div>
          </div>
        </div>
        <div *ngIf="spinner" class="ng-spinner">
          <div class="ng-spinner-icon"
               [style.borderTopColor]="color"
               [style.borderLeftColor]="color"></div>
        </div>
      </div>
    </ng-container>
  `, changeDetection: ChangeDetectionStrategy.OnPush, styles: [":host{z-index:999999;pointer-events:none}:host[fixed=true] .ng-progress-bar,:host[fixed=true] .ng-spinner{position:fixed}:host[fixed=true] .ng-spinner{top:15px}:host[fixed=true][spinnerPosition=left] .ng-spinner{left:15px}:host[fixed=true][spinnerPosition=right] .ng-spinner{right:15px}:host[thick=true] .ng-spinner-icon{width:24px;height:24px;border-width:3px}:host[thick=true] .ng-bar-placeholder{height:3px!important}:host[direction=\"ltr+\"] .ng-meteor,:host[direction=ltr-] .ng-meteor{transform:rotate(3deg)}:host[direction=\"ltr+\"][thick=true] .ng-meteor,:host[direction=ltr-][thick=true] .ng-meteor{transform:rotate(4deg)}:host[direction=\"ltr+\"] .ng-bar,:host[direction=\"rtl+\"] .ng-bar{margin-left:-100%}:host[direction=\"ltr+\"] .ng-meteor,:host[direction=\"rtl+\"] .ng-meteor{right:0}:host[direction=\"ltr+\"] .ng-meteor,:host[direction=rtl-] .ng-meteor{top:-3px}:host[direction=\"ltr+\"][thick=true] .ng-meteor,:host[direction=rtl-][thick=true] .ng-meteor{top:-4px}:host[direction=ltr-] .ng-meteor,:host[direction=\"rtl+\"] .ng-meteor{bottom:-3px}:host[direction=ltr-][thick=true] .ng-meteor,:host[direction=\"rtl+\"][thick=true] .ng-meteor{bottom:-4px}:host[direction=ltr-] .ng-bar-placeholder,:host[direction=\"rtl+\"] .ng-bar-placeholder{transform:rotate(180deg)}:host[direction=ltr-] .ng-spinner-icon,:host[direction=\"rtl+\"] .ng-spinner-icon{animation-directionection:reverse}:host[direction=\"rtl+\"] .ng-meteor,:host[direction=rtl-] .ng-meteor{transform:rotate(-3deg)}:host[direction=\"rtl+\"][thick=true] .ng-meteor,:host[direction=rtl-][thick=true] .ng-meteor{transform:rotate(-4deg)}:host[spinnerPosition=left] .ng-spinner{left:10px}:host[spinnerPosition=right] .ng-spinner{right:10px}.ng-progress-bar{position:relative;z-index:999999;top:0;left:0;width:100%;transform:scale(1);filter:alpha(opacity=0);opacity:0}.ng-progress-bar[active=true]{filter:alpha(opacity=100);opacity:1;transition:none}.ng-bar-placeholder{position:absolute;height:2px;width:100%}.ng-bar{width:100%;height:100%;transform:translate(-100%,0,0)}.ng-meteor{display:block;position:absolute;width:100px;height:100%;opacity:1}.ng-spinner{position:absolute;display:block;z-index:1031;top:10px}.ng-spinner-icon{width:18px;height:18px;box-sizing:border-box;-webkit-animation:spinner-animation .25s linear infinite;animation:spinner-animation .25s linear infinite;border:2px solid transparent;border-radius:50%}@-webkit-keyframes spinner-animation{0%{transform:rotate(0)}to{transform:rotate(360deg)}}@keyframes spinner-animation{0%{transform:rotate(0)}to{transform:rotate(360deg)}}\n"] }]
        }], ctorParameters: function () { return [{ type: i1.NgProgress }]; }, propDecorators: { id: [{
                type: Input
            }], min: [{
                type: Input
            }], max: [{
                type: Input
            }], ease: [{
                type: Input
            }], color: [{
                type: Input
            }], speed: [{
                type: Input
            }], thick: [{
                type: Input
            }], fixed: [{
                type: Input
            }], meteor: [{
                type: Input
            }], spinner: [{
                type: Input
            }], trickleSpeed: [{
                type: Input
            }], debounceTime: [{
                type: Input
            }], trickleFunc: [{
                type: Input
            }], spinnerPosition: [{
                type: Input
            }], direction: [{
                type: Input
            }], started: [{
                type: Output
            }], completed: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmctcHJvZ3Jlc3MuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvbmd4LXByb2dyZXNzYmFyL3NyYy9saWIvbmctcHJvZ3Jlc3MuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxTQUFTLEVBQ1QsS0FBSyxFQUNMLE1BQU0sRUFDTixZQUFZLEVBSVosdUJBQXVCLEVBQ3hCLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7OztBQXVDckMsTUFBTSxPQUFPLG1CQUFtQjtJQW9DOUIsWUFBb0IsV0FBdUI7UUFBdkIsZ0JBQVcsR0FBWCxXQUFXLENBQVk7UUF6QjNDLHlEQUF5RDtRQUNoRCxPQUFFLEdBQUcsTUFBTSxDQUFDO1FBRXJCLGdEQUFnRDtRQUN2QyxRQUFHLEdBQVcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDO1FBQzFDLFFBQUcsR0FBVyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUM7UUFDMUMsU0FBSSxHQUFXLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQztRQUM1QyxVQUFLLEdBQVcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDO1FBQzlDLFVBQUssR0FBVyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUM7UUFDOUMsVUFBSyxHQUFZLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQztRQUMvQyxVQUFLLEdBQVksSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDO1FBQy9DLFdBQU0sR0FBWSxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUM7UUFDakQsWUFBTyxHQUFZLElBQUksQ0FBQyxXQUFX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S0FBSztnQkFDRyxZQUFZO3NCQUFwQixLQUFLO2dCQUNHLFlBQVk7c0JBQXBCLEtBQUs7Z0JBQ0csV0FBVztzQkFBbkIsS0FBSztnQkFDRyxlQUFlO3NCQUF2QixLQUFLO2dCQUNHLFNBQVM7c0JBQWpCLEtBQUs7Z0JBQ0ksT0FBTztzQkFBaEIsTUFBTTtnQkFDRyxTQUFTO3NCQUFsQixNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICBDb21wb25lbnQsXHJcbiAgSW5wdXQsXHJcbiAgT3V0cHV0LFxyXG4gIEV2ZW50RW1pdHRlcixcclxuICBPbkNoYW5nZXMsXHJcbiAgT25EZXN0cm95LFxyXG4gIE9uSW5pdCxcclxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneVxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQgeyBOZ1Byb2dyZXNzIH0gZnJvbSAnLi9uZy1wcm9ncmVzcy5zZXJ2aWNlJztcclxuaW1wb3J0IHsgTmdQcm9ncmVzc1JlZiB9IGZyb20gJy4vbmctcHJvZ3Jlc3MtcmVmJztcclxuaW1wb3J0IHsgUHJvZ3Jlc3NTdGF0ZSB9IGZyb20gJy4vbmctcHJvZ3Jlc3MuaW50ZXJmYWNlJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gIHNlbGVjdG9yOiAnbmctcHJvZ3Jlc3MnLFxyXG4gIGhvc3Q6IHtcclxuICAgICdyb2xlJzogJ3Byb2dyZXNzYmFyJyxcclxuICAgICdbYXR0ci5zcGlubmVyUG9zaXRpb25dJzogJ3NwaW5uZXJQb3NpdGlvbicsXHJcbiAgICAnW2F0dHIuZGlyZWN0aW9uXSc6ICdkaXJlY3Rpb24nLFxyXG4gICAgJ1thdHRyLnRoaWNrXSc6ICd0aGljaycsXHJcbiAgICAnW2F0dHIuZml4ZWRdJzogJ2ZpeGVkJ1xyXG4gIH0sXHJcbiAgdGVtcGxhdGU6IGBcclxuICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJzdGF0ZSQgfCBhc3luYzsgbGV0IHN0YXRlXCI+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJuZy1wcm9ncmVzcy1iYXJcIlxyXG4gICAgICAgICAgIFthdHRyLmFjdGl2ZV09XCJzdGF0ZS5hY3RpdmVcIlxyXG4gICAgICAgICAgIFtzdHlsZS50cmFuc2l0aW9uXT1cIidvcGFjaXR5ICcgKyBzcGVlZCArICdtcyAnICsgZWFzZVwiPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJuZy1iYXItcGxhY2Vob2xkZXJcIj5cclxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJuZy1iYXJcIlxyXG4gICAgICAgICAgICAgICBbc3R5bGUudHJhbnNmb3JtXT1cInN0YXRlLnRyYW5zZm9ybVwiXHJcbiAgICAgICAgICAgICAgIFtzdHlsZS5iYWNrZ3JvdW5kQ29sb3JdPVwiY29sb3JcIlxyXG4gICAgICAgICAgICAgICBbc3R5bGUudHJhbnNpdGlvbl09XCJzdGF0ZS5hY3RpdmUgPyAnYWxsICcgKyBzcGVlZCArICdtcyAnICsgZWFzZSA6ICdub25lJ1wiPlxyXG4gICAgICAgICAgICA8ZGl2ICpuZ0lmPVwibWV0ZW9yXCIgY2xhc3M9XCJuZy1tZXRlb3JcIiBbc3R5bGUuYm94U2hhZG93XT1cIicwIDAgMTBweCAnKyBjb2xvciArICcsIDAgMCA1cHggJyArIGNvbG9yXCI+PC9kaXY+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2ICpuZ0lmPVwic3Bpbm5lclwiIGNsYXNzPVwibmctc3Bpbm5lclwiPlxyXG4gICAgICAgICAgPGRpdiBjbGFzcz1cIm5nLXNwaW5uZXItaWNvblwiXHJcbiAgICAgICAgICAgICAgIFtzdHlsZS5ib3JkZXJUb3BDb2xvcl09XCJjb2xvclwiXHJcbiAgICAgICAgICAgICAgIFtzdHlsZS5ib3JkZXJMZWZ0Q29sb3JdPVwiY29sb3JcIj48L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICA8L25nLWNvbnRhaW5lcj5cclxuICBgLFxyXG4gIHN0eWxlVXJsczogWycuL25nLXByb2dyZXNzLmNvbXBvbmVudC5zY3NzJ10sXHJcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxufSlcclxuXHJcbmV4cG9ydCBjbGFzcyBOZ1Byb2dyZXNzQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XHJcblxyXG4gIHByaXZhdGUgX3N0YXJ0ZWQhOiBTdWJzY3JpcHRpb247XHJcbiAgcHJpdmF0ZSBfY29tcGxldGVkITogU3Vic2NyaXB0aW9uO1xyXG5cclxuICAvKiogUHJvZ3Jlc3MgYmFyIHdvcmtlciAqL1xyXG4gIHByb2dyZXNzUmVmITogTmdQcm9ncmVzc1JlZjtcclxuXHJcbiAgLyoqIFN0cmVhbSB0aGF0IGVtaXRzIHByb2dyZXNzIHN0YXRlICovXHJcbiAgc3RhdGUkITogT2JzZXJ2YWJsZTx7IGFjdGl2ZTogYm9vbGVhbiwgdHJhbnNmb3JtOiBzdHJpbmcgfT47XHJcblxyXG4gIC8qKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIGlmIGlkIGlzIG5vdCBhbHJlYWR5IGV4aXN0cyAqL1xyXG4gIEBJbnB1dCgpIGlkID0gJ3Jvb3QnO1xyXG5cclxuICAvKiogSW5pdGlhbGl6ZXMgaW5wdXRzIGZyb20gdGhlIGdsb2JhbCBjb25maWcgKi9cclxuICBASW5wdXQoKSBtaW46IG51bWJlciA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLm1pbjtcclxuICBASW5wdXQoKSBtYXg6IG51bWJlciA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLm1heDtcclxuICBASW5wdXQoKSBlYXNlOiBzdHJpbmcgPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy5lYXNlO1xyXG4gIEBJbnB1dCgpIGNvbG9yOiBzdHJpbmcgPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy5jb2xvcjtcclxuICBASW5wdXQoKSBzcGVlZDogbnVtYmVyID0gdGhpcy5fbmdQcm9ncmVzcy5jb25maWcuc3BlZWQ7XHJcbiAgQElucHV0KCkgdGhpY2s6IGJvb2xlYW4gPSB0aGlzLl9uZ1Byb2dyZXNzLmNvbmZpZy50aGljaztcclxuICBASW5wdXQoKSBmaXhlZDogYm9vbGVhbiA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLmZpeGVkO1xyXG4gIEBJbnB1dCgpIG1ldGVvcjogYm9vbGVhbiA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLm1ldGVvcjtcclxuICBASW5wdXQoKSBzcGlubmVyOiBib29sZWFuID0gdGhpcy5fbmdQcm9ncmVzcy5jb25maWcuc3Bpbm5lcjtcclxuICBASW5wdXQoKSB0cmlja2xlU3BlZWQ6IG51bWJlciA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLnRyaWNrbGVTcGVlZDtcclxuICBASW5wdXQoKSBkZWJvdW5jZVRpbWU6IG51bWJlciA9IHRoaXMuX25nUHJvZ3Jlc3MuY29uZmlnLmRlYm91bmNlVGltZTtcclxuICBASW5wdXQoKSB0cmlja2xlRnVuYzogKG46IG51bWJlcikgPT4gbnVtYmVyID0gdGhpcy5fbmdQcm9ncmVzcy5jb25maWcudHJpY2tsZUZ1bmM7XHJcbiAgQElucHV0KCkgc3Bpbm5lclBvc2l0aW9uOiAnbGVmdCcgfCAncmlnaHQnID0gdGhpcy5fbmdQcm9ncmVzcy5jb25maWcuc3Bpbm5lclBvc2l0aW9uO1xyXG4gIEBJbnB1dCgpIGRpcmVjdGlvbjogJ2x0cisnIHwgJ2x0ci0nIHwgJ3J0bCsnIHwgJ3J0bC0nID0gdGhpcy5fbmdQcm9ncmVzcy5jb25maWcuZGlyZWN0aW9uO1xyXG4gIEBPdXRwdXQoKSBzdGFydGVkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG4gIEBPdXRwdXQoKSBjb21wbGV0ZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcblxyXG4gIGdldCBpc1N0YXJ0ZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5wcm9ncmVzc1JlZj8uaXNTdGFydGVkO1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfbmdQcm9ncmVzczogTmdQcm9ncmVzcykge1xyXG4gIH1cclxuXHJcbiAgbmdPbkNoYW5nZXMoKSB7XHJcbiAgICAgLy8gVXBkYXRlIHByb2dyZXNzIGJhciBjb25maWcgd2hlbiBpbnB1dHMgY2hhbmdlXHJcbiAgICB0aGlzLnByb2dyZXNzUmVmPy5zZXRDb25maWcoe1xyXG4gICAgICBtYXg6ICh0aGlzLm1heCA+IDAgJiYgdGhpcy5tYXggPD0gMTAwKSA/IHRoaXMubWF4IDogMTAwLFxyXG4gICAgICBtaW46ICh0aGlzLm1pbiA8IDEwMCAmJiB0aGlzLm1pbiA+PSAwKSA/IHRoaXMubWluIDogMCxcclxuICAgICAgc3BlZWQ6IHRoaXMuc3BlZWQsXHJcbiAgICAgIHRyaWNrbGVTcGVlZDogdGhpcy50cmlja2xlU3BlZWQsXHJcbiAgICAgIHRyaWNrbGVGdW5jOiB0aGlzLnRyaWNrbGVGdW5jLFxyXG4gICAgICBkZWJvdW5jZVRpbWU6IHRoaXMuZGVib3VuY2VUaW1lXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIG5nT25Jbml0KCkge1xyXG4gICAgLy8gR2V0IHByb2dyZXNzIGJhciBzZXJ2aWNlIGluc3RhbmNlXHJcbiAgICB0aGlzLnByb2dyZXNzUmVmID0gdGhpcy5fbmdQcm9ncmVzcy5yZWYodGhpcy5pZCwge1xyXG4gICAgICBtYXg6IHRoaXMubWF4LFxyXG4gICAgICBtaW46IHRoaXMubWluLFxyXG4gICAgICBzcGVlZDogdGhpcy5zcGVlZCxcclxuICAgICAgdHJpY2tsZVNwZWVkOiB0aGlzLnRyaWNrbGVTcGVlZCxcclxuICAgICAgZGVib3VuY2VUaW1lOiB0aGlzLmRlYm91bmNlVGltZVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gU3Vic2NyaWJlIHRvIHByb2dyZXNzIHN0YXRlXHJcbiAgICB0aGlzLnN0YXRlJCA9IHRoaXMucHJvZ3Jlc3NSZWYuc3RhdGUucGlwZShcclxuICAgICAgbWFwKChzdGF0ZTogUHJvZ3Jlc3NTdGF0ZSkgPT4gKHtcclxuICAgICAgICBhY3RpdmU6IHN0YXRlLmFjdGl2ZSxcclxuICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgkeyBzdGF0ZS52YWx1ZSB9JSwwLDApYFxyXG4gICAgICB9KSlcclxuICAgICk7XHJcblxyXG4gICAgLy8gU3Vic2NyaWJlcyB0byBzdGFydGVkIGFuZCBjb21wbGV0ZWQgZXZlbnRzIG9uIGRlbWFuZFxyXG4gICAgaWYgKHRoaXMuc3RhcnRlZC5vYnNlcnZlZCkge1xyXG4gICAgICB0aGlzLl9zdGFydGVkID0gdGhpcy5wcm9ncmVzc1JlZi5zdGFydGVkLnN1YnNjcmliZSgoKSA9PiB0aGlzLnN0YXJ0ZWQuZW1pdCgpKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLmNvbXBsZXRlZC5vYnNlcnZlZCkge1xyXG4gICAgICB0aGlzLl9jb21wbGV0ZWQgPSB0aGlzLnByb2dyZXNzUmVmLmNvbXBsZXRlZC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jb21wbGV0ZWQuZW1pdCgpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG5nT25EZXN0cm95KCkge1xyXG4gICAgdGhpcy5fc3RhcnRlZD8udW5zdWJzY3JpYmUoKTtcclxuICAgIHRoaXMuX2NvbXBsZXRlZD8udW5zdWJzY3JpYmUoKTtcclxuICAgIHRoaXMucHJvZ3Jlc3NSZWY/LmRlc3Ryb3koKTtcclxuICB9XHJcblxyXG4gIHN0YXJ0KCkge1xyXG4gICAgdGhpcy5wcm9ncmVzc1JlZi5zdGFydCgpO1xyXG4gIH1cclxuXHJcbiAgY29tcGxldGUoKSB7XHJcbiAgICB0aGlzLnByb2dyZXNzUmVmLmNvbXBsZXRlKCk7XHJcbiAgfVxyXG5cclxuICBpbmMobj86IG51bWJlcikge1xyXG4gICAgdGhpcy5wcm9ncmVzc1JlZi5pbmMobik7XHJcbiAgfVxyXG5cclxuICBzZXQobjogbnVtYmVyKSB7XHJcbiAgICB0aGlzLnByb2dyZXNzUmVmLnNldChuKTtcclxuICB9XHJcbn1cclxuIl19