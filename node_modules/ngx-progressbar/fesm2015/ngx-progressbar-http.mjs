import * as i0 from '@angular/core';
import { InjectionToken, Injectable, Optional, Inject, NgModule } from '@angular/core';
import { HTTP_INTERCEPTORS } from '@angular/common/http';
import { finalize } from 'rxjs/operators';
import * as i1 from 'ngx-progressbar';

const NG_PROGRESS_HTTP_CONFIG = new InjectionToken('ngProgressHttpConfig');

class NgProgressInterceptor {
    constructor(ngProgress, config) {
        this.ngProgress = ngProgress;
        this._inProgressCount = 0;
        this._config = {
            id: 'root',
            silentApis: [],
            matcher: undefined
        };
        this._config = config ? Object.assign(Object.assign({}, this._config), config) : this._config;
    }
    intercept(req, next) {
        // Ignore by request headers
        if (req.headers.has('ignoreProgressBar')) {
            return next.handle(req.clone({ headers: req.headers.delete('ignoreProgressBar') }));
        }
        // Ignore silent api requests
        if (this.checkUrl(req)) {
            return next.handle(req);
        }
        this._inProgressCount++;
        this._progressRef = this.ngProgress.ref(this._config.id);
        if (!this._progressRef.isStarted) {
            this._progressRef.start();
        }
        return next.handle(req).pipe(finalize(() => {
            this._inProgressCount--;
            if (this._inProgressCount === 0) {
                this._progressRef.complete();
            }
        }));
    }
    /**
     * Check if request is silent.
     * @param req request
     */
    checkUrl(req) {
        var _a, _b;
        const url = req.url.toLowerCase();
        if (this._config.matcher && ((_a = this._config.silentApis) === null || _a === void 0 ? void 0 : _a.length)) {
            return checkForMatcher(url, this._config.matcher) && checkForSilentApis(url, this._config.silentApis);
        }
        if ((_b = this._config.silentApis) === null || _b === void 0 ? void 0 : _b.length) {
            return checkForSilentApis(url, this._config.silentApis);
        }
        if (this._config.matcher) {
            return checkForMatcher(url, this._config.matcher);
        }
        return false;
    }
}
NgProgressInterceptor.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: NgProgressInterceptor, deps: [{ token: i1.NgProgress }, { token: NG_PROGRESS_HTTP_CONFIG, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
NgProgressInterceptor.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: NgProgressInterceptor });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: NgProgressInterceptor, decorators: [{
            type: Injectable
        }], ctorParameters: function () {
        return [{ type: i1.NgProgress }, { type: undefined, decorators: [{
                        type: Optional
                    }, {
                        type: Inject,
                        args: [NG_PROGRESS_HTTP_CONFIG]
                    }] }];
    } });
function checkForSilentApis(url, silentApis) {
    return !!silentApis.find((u) => url.includes(u.toLowerCase()));
}
function checkForMatcher(url, matcher) {
    return !!url.match(matcher);
}

class NgProgressHttpModule {
    static withConfig(config) {
        return {
            ngModule: NgProgressHttpModule,
            providers: [
                { provide: NG_PROGRESS_HTTP_CONFIG, useValue: config }
            ]
        };
    }
}
NgProgressHttpModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: NgProgressHttpModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgProgressHttpModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.0.0", ngImport: i0, type: NgProgressHttpModule });
NgProgressHttpModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: NgProgressHttpModule, providers: [
        { provide: HTTP_INTERCEPTORS, useClass: NgProgressInterceptor, multi: true }
    ] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: NgProgressHttpModule, decorators: [{
            type: NgModule,
            args: [{
                    providers: [
                        { provide: HTTP_INTERCEPTORS, useClass: NgProgressInterceptor, multi: true }
                    ]
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { NG_PROGRESS_HTTP_CONFIG, NgProgressHttpModule, NgProgressInterceptor };
//# sourceMappingURL=ngx-progressbar-http.mjs.map
