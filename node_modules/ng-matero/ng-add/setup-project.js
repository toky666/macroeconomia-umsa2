"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@angular-devkit/core");
const schematics_1 = require("@angular-devkit/schematics");
const schematics_2 = require("@angular/cdk/schematics");
const tasks_1 = require("@angular-devkit/schematics/tasks");
const workspace_1 = require("@schematics/angular/utility/workspace");
const ng_ast_utils_1 = require("@schematics/angular/utility/ng-ast-utils");
const theming_1 = require("./theming");
const material_fonts_1 = require("./material-fonts");
const global_loader_1 = require("./global-loader");
const package_config_1 = require("./package-config");
const packages_1 = require("./packages");
/** Name of the Angular module that enables Angular browser animations. */
const browserAnimationsModuleName = 'BrowserAnimationsModule';
/** Name of the module that switches Angular animations to a noop implementation. */
const noopAnimationsModuleName = 'NoopAnimationsModule';
/**
 * Scaffolds the basics of a Angular Material application, this includes:
 *  - Add Starter files to root
 *  - Add Scripts to `package.json`
 *  - Add proxy to `angular.json`
 *  - Add style to `angular.json`
 *  - Add Browser Animation to app.module
 *  - Add Fonts & Icons to `index.html`
 *  - Add Preloader to `index.html`
 *  - Add Packages to `package.json`
 */
function default_1(options) {
    return (0, schematics_1.chain)([
        deleteExsitingFiles(options),
        addStarterFiles(options),
        addScriptsToPackageJson(),
        addESLintToAngularJson(options),
        addProxyToAngularJson(options),
        addStyleToAngularJson(options),
        addAnimationsModule(options),
        (0, material_fonts_1.addFontsToIndex)(options),
        (0, global_loader_1.addLoaderToIndex)(options),
        installPackages(),
    ]);
}
exports.default = default_1;
/**
 * Adds an animation module to the root module of the specified project. In case the "animations"
 * option is set to false, we still add the `NoopAnimationsModule` because otherwise various
 * components of Angular Material will throw an exception.
 */
function addAnimationsModule(options) {
    return (host, context) => __awaiter(this, void 0, void 0, function* () {
        const workspace = yield (0, workspace_1.getWorkspace)(host);
        const project = (0, schematics_2.getProjectFromWorkspace)(workspace, options.project);
        const appModulePath = (0, ng_ast_utils_1.getAppModulePath)(host, (0, schematics_2.getProjectMainFile)(project));
        if (options.animations) {
            // In case the project explicitly uses the NoopAnimationsModule, we should print a warning
            // message that makes the user aware of the fact that we won't automatically set up
            // animations. If we would add the BrowserAnimationsModule while the NoopAnimationsModule
            // is already configured, we would cause unexpected behavior and runtime exceptions.
            if ((0, schematics_2.hasNgModuleImport)(host, appModulePath, noopAnimationsModuleName)) {
                context.logger.error(`Could not set up "${browserAnimationsModuleName}" ` +
                    `because "${noopAnimationsModuleName}" is already imported.`);
                context.logger.info(`Please manually set up browser animations.`);
                return;
            }
            (0, schematics_2.addModuleImportToRootModule)(host, browserAnimationsModuleName, '@angular/platform-browser/animations', project);
        }
        else if (!(0, schematics_2.hasNgModuleImport)(host, appModulePath, browserAnimationsModuleName)) {
            // Do not add the NoopAnimationsModule module if the project already explicitly uses
            // the BrowserAnimationsModule.
            (0, schematics_2.addModuleImportToRootModule)(host, noopAnimationsModuleName, '@angular/platform-browser/animations', project);
        }
    });
}
/** delete exsiting files to be overwrite */
function deleteExsitingFiles(options) {
    return (host) => __awaiter(this, void 0, void 0, function* () {
        const workspace = yield (0, workspace_1.getWorkspace)(host);
        const project = (0, schematics_2.getProjectFromWorkspace)(workspace, options.project);
        [
            `${project.root}/.vscode/extensions.json`,
            `${project.root}/.vscode/settings.json`,
            `${project.root}/tsconfig.json`,
            `${project.root}/tsconfig.app.json`,
            `${project.root}/tsconfig.base.json`,
            `${project.root}/tsconfig.spec.json`,
            `${project.sourceRoot}/app/app-routing.module.ts`,
            `${project.sourceRoot}/app/app.module.ts`,
            `${project.sourceRoot}/app/app.component.spec.ts`,
            `${project.sourceRoot}/app/app.component.ts`,
            `${project.sourceRoot}/app/app.component.html`,
            `${project.sourceRoot}/app/app.component.scss`,
            `${project.sourceRoot}/environments/environment.prod.ts`,
            `${project.sourceRoot}/environments/environment.ts`,
            `${project.sourceRoot}/styles.scss`,
        ]
            .filter(p => host.exists(p))
            .forEach(p => host.delete(p));
    });
}
/** Add scripts to `package.json` */
function addScriptsToPackageJson() {
    return (host) => {
        (0, package_config_1.addScriptToPackageJson)(host, 'build:prod', 'ng build --prod');
        (0, package_config_1.addScriptToPackageJson)(host, 'lint', `npm run lint:ts && npm run lint:scss`);
        (0, package_config_1.addScriptToPackageJson)(host, 'lint:ts', `eslint "src/**/*.ts" --fix`);
        (0, package_config_1.addScriptToPackageJson)(host, 'lint:scss', `stylelint "src/**/*.scss" --fix`);
        (0, package_config_1.addScriptToPackageJson)(host, 'hmr', `ng serve --hmr --disable-host-check`);
    };
}
/** Add ESLint to `angular.json` */
function addESLintToAngularJson(options) {
    return (0, workspace_1.updateWorkspace)(workspace => {
        const project = (0, schematics_2.getProjectFromWorkspace)(workspace, options.project);
        let lintFilePatternsRoot = '';
        // Default Angular CLI project at the root of the workspace
        if (project.root === '') {
            lintFilePatternsRoot = 'src';
        }
        else {
            lintFilePatternsRoot = project.root;
        }
        const eslintTargetConfig = {
            builder: '@angular-eslint/builder:lint',
            options: {
                lintFilePatterns: [`${lintFilePatternsRoot}/**/*.ts`, `${lintFilePatternsRoot}/**/*.html`],
            },
        };
        project.targets.set('lint', eslintTargetConfig);
    });
}
/** Add proxy to `angular.json` */
function addProxyToAngularJson(options) {
    return (0, workspace_1.updateWorkspace)(workspace => {
        var _a, _b;
        const project = (0, schematics_2.getProjectFromWorkspace)(workspace, options.project);
        const targetServeConfig = (_b = (_a = project.targets) === null || _a === void 0 ? void 0 : _a.get('serve')) === null || _b === void 0 ? void 0 : _b.configurations;
        if (targetServeConfig.options) {
            targetServeConfig.options.proxyConfig = 'proxy.config.js';
        }
        else {
            targetServeConfig.options = {
                proxyConfig: 'proxy.config.js',
            };
        }
    });
}
/** Add style to `angular.json` */
function addStyleToAngularJson(options) {
    return (_host, context) => {
        // Path needs to be always relative to the `package.json` or workspace root.
        const themePath = `src/styles.scss`;
        return (0, schematics_1.chain)([
            (0, theming_1.addThemeStyleToTarget)(options.project, 'build', themePath, context.logger),
            (0, theming_1.addThemeStyleToTarget)(options.project, 'test', themePath, context.logger),
        ]);
    };
}
/** Add starter files to root */
function addStarterFiles(options) {
    return (0, schematics_1.chain)([
        (0, schematics_1.mergeWith)((0, schematics_1.apply)((0, schematics_1.url)('./files'), [
            (0, schematics_1.template)(Object.assign(Object.assign({}, core_1.strings), options)),
        ])),
    ]);
}
/** Install packages */
function installPackages() {
    return (host, context) => {
        // Add 3rd packages
        (0, packages_1.add3rdPkgsToPackageJson)(host);
        context.addTask(new tasks_1.NodePackageInstallTask());
    };
}
//# sourceMappingURL=setup-project.js.map