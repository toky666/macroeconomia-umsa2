import { Component, ChangeDetectionStrategy, ViewChild, } from '@angular/core';
import { ɵobserve as observe } from '@ngx-formly/core';
import { FieldType } from '@ngx-formly/material/form-field';
import * as i0 from "@angular/core";
import * as i1 from "@ngx-formly/core";
import * as i2 from "@angular/material/datepicker";
import * as i3 from "@angular/material/input";
import * as i4 from "@angular/forms";
export class FormlyFieldDatepicker extends FieldType {
    constructor(config, cdRef) {
        super();
        this.config = config;
        this.cdRef = cdRef;
        this.defaultOptions = {
            props: {
                datepickerOptions: {
                    startView: 'month',
                    datepickerTogglePosition: 'suffix',
                    disabled: false,
                    opened: false,
                    dateInput: () => { },
                    dateChange: () => { },
                    monthSelected: () => { },
                    yearSelected: () => { },
                },
            },
        };
    }
    detectChanges() {
        this.options.detectChanges?.(this.field);
    }
    ngAfterViewInit() {
        this.props[this.props.datepickerOptions.datepickerTogglePosition] = this.datepickerToggle;
        observe(this.field, ['props', 'datepickerOptions', 'opened'], () => {
            this.cdRef.detectChanges();
        });
        // temporary fix for https://github.com/angular/components/issues/16761
        if (this.config.getValidatorMessage('matDatepickerParse')) {
            this.fieldErrorsObserver = observe(this.field, ['formControl', 'errors'], ({ currentValue }) => {
                if (currentValue && currentValue.required && currentValue.matDatepickerParse) {
                    const errors = Object.keys(currentValue)
                        .sort((prop) => (prop === 'matDatepickerParse' ? -1 : 0))
                        .reduce((errors, prop) => ({ ...errors, [prop]: currentValue[prop] }), {});
                    this.fieldErrorsObserver?.setValue(errors);
                }
            });
        }
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        this.fieldErrorsObserver?.unsubscribe();
    }
}
FormlyFieldDatepicker.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.11", ngImport: i0, type: FormlyFieldDatepicker, deps: [{ token: i1.FormlyConfig }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
FormlyFieldDatepicker.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.11", type: FormlyFieldDatepicker, selector: "formly-field-mat-datepicker", viewQueries: [{ propertyName: "datepickerToggle", first: true, predicate: ["datepickerToggle"], descendants: true, static: true }], usesInheritance: true, ngImport: i0, template: `
    <input
      matInput
      [id]="id"
      [errorStateMatcher]="errorStateMatcher"
      [formControl]="formControl"
      [matDatepicker]="picker"
      [matDatepickerFilter]="props.datepickerOptions.filter"
      [max]="props.datepickerOptions.max"
      [min]="props.datepickerOptions.min"
      [formlyAttributes]="field"
      [placeholder]="props.placeholder"
      [tabindex]="props.tabindex"
      [readonly]="props.readonly"
      [required]="required"
      (dateInput)="props.datepickerOptions.dateInput(field, $event)"
      (dateChange)="props.datepickerOptions.dateChange(field, $event)"
    />
    <ng-template #datepickerToggle>
      <mat-datepicker-toggle
        (click)="detectChanges()"
        [disabled]="props.disabled"
        [for]="picker"
      ></mat-datepicker-toggle>
    </ng-template>
    <mat-datepicker
      #picker
      [color]="props.color"
      [dateClass]="props.datepickerOptions.dateClass"
      [disabled]="props.datepickerOptions.disabled"
      [opened]="props.datepickerOptions.opened"
      [panelClass]="props.datepickerOptions.panelClass"
      [startAt]="props.datepickerOptions.startAt"
      [startView]="props.datepickerOptions.startView"
      [touchUi]="props.datepickerOptions.touchUi"
      [calendarHeaderComponent]="props.datepickerOptions.calendarHeaderComponent"
      (monthSelected)="props.datepickerOptions.monthSelected(field, $event, picker)"
      (yearSelected)="props.datepickerOptions.yearSelected(field, $event, picker)"
      (opened)="props.datepickerOptions.opened = true"
      (closed)="props.datepickerOptions.opened = false"
    >
    </mat-datepicker>
  `, isInline: true, components: [{ type: i2.MatDatepickerToggle, selector: "mat-datepicker-toggle", inputs: ["for", "tabIndex", "aria-label", "disabled", "disableRipple"], exportAs: ["matDatepickerToggle"] }, { type: i2.MatDatepicker, selector: "mat-datepicker", exportAs: ["matDatepicker"] }], directives: [{ type: i3.MatInput, selector: "input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]", inputs: ["disabled", "id", "placeholder", "name", "required", "type", "errorStateMatcher", "aria-describedby", "value", "readonly"], exportAs: ["matInput"] }, { type: i4.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { type: i2.MatDatepickerInput, selector: "input[matDatepicker]", inputs: ["matDatepicker", "min", "max", "matDatepickerFilter"], exportAs: ["matDatepickerInput"] }, { type: i4.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i4.FormControlDirective, selector: "[formControl]", inputs: ["formControl", "disabled", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { type: i1.ɵFormlyAttributes, selector: "[formlyAttributes]", inputs: ["formlyAttributes", "id"] }, { type: i4.RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: ["required"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.11", ngImport: i0, type: FormlyFieldDatepicker, decorators: [{
            type: Component,
            args: [{
                    selector: 'formly-field-mat-datepicker',
                    template: `
    <input
      matInput
      [id]="id"
      [errorStateMatcher]="errorStateMatcher"
      [formControl]="formControl"
      [matDatepicker]="picker"
      [matDatepickerFilter]="props.datepickerOptions.filter"
      [max]="props.datepickerOptions.max"
      [min]="props.datepickerOptions.min"
      [formlyAttributes]="field"
      [placeholder]="props.placeholder"
      [tabindex]="props.tabindex"
      [readonly]="props.readonly"
      [required]="required"
      (dateInput)="props.datepickerOptions.dateInput(field, $event)"
      (dateChange)="props.datepickerOptions.dateChange(field, $event)"
    />
    <ng-template #datepickerToggle>
      <mat-datepicker-toggle
        (click)="detectChanges()"
        [disabled]="props.disabled"
        [for]="picker"
      ></mat-datepicker-toggle>
    </ng-template>
    <mat-datepicker
      #picker
      [color]="props.color"
      [dateClass]="props.datepickerOptions.dateClass"
      [disabled]="props.datepickerOptions.disabled"
      [opened]="props.datepickerOptions.opened"
      [panelClass]="props.datepickerOptions.panelClass"
      [startAt]="props.datepickerOptions.startAt"
      [startView]="props.datepickerOptions.startView"
      [touchUi]="props.datepickerOptions.touchUi"
      [calendarHeaderComponent]="props.datepickerOptions.calendarHeaderComponent"
      (monthSelected)="props.datepickerOptions.monthSelected(field, $event, picker)"
      (yearSelected)="props.datepickerOptions.yearSelected(field, $event, picker)"
      (opened)="props.datepickerOptions.opened = true"
      (closed)="props.datepickerOptions.opened = false"
    >
    </mat-datepicker>
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                }]
        }], ctorParameters: function () { return [{ type: i1.FormlyConfig }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { datepickerToggle: [{
                type: ViewChild,
                args: ['datepickerToggle', { static: true }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZXBpY2tlci50eXBlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL3VpL21hdGVyaWFsL2RhdGVwaWNrZXIvc3JjL2RhdGVwaWNrZXIudHlwZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULHVCQUF1QixFQUN2QixTQUFTLEdBTVYsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFvRCxRQUFRLElBQUksT0FBTyxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDekcsT0FBTyxFQUFFLFNBQVMsRUFBb0IsTUFBTSxpQ0FBaUMsQ0FBQzs7Ozs7O0FBOEU5RSxNQUFNLE9BQU8scUJBQ1gsU0FBUSxTQUEyQztJQXFCbkQsWUFBb0IsTUFBb0IsRUFBVSxLQUF3QjtRQUN4RSxLQUFLLEVBQUUsQ0FBQztRQURVLFdBQU0sR0FBTixNQUFNLENBQWM7UUFBVSxVQUFLLEdBQUwsS0FBSyxDQUFtQjtRQWhCakUsbUJBQWMsR0FBRztZQUN4QixLQUFLLEVBQUU7Z0JBQ0wsaUJBQWlCLEVBQUU7b0JBQ2pCLFNBQVMsRUFBRSxPQUFnQjtvQkFDM0Isd0JBQXdCLEVBQUUsUUFBaUI7b0JBQzNDLFFBQVEsRUFBRSxLQUFLO29CQUNmLE1BQU0sRUFBRSxLQUFLO29CQUNiLFNBQVMsRUFBRSxHQUFHLEVBQUUsR0FBRSxDQUFDO29CQUNuQixVQUFVLEVBQUUsR0FBRyxFQUFFLEdBQUUsQ0FBQztvQkFDcEIsYUFBYSxFQUFFLEdBQUcsRUFBRSxHQUFFLENBQUM7b0JBQ3ZCLFlBQVksRUFBRSxHQUFHLEVBQUUsR0FBRSxDQUFDO2lCQUN2QjthQUNGO1NBQ0YsQ0FBQztJQUtGLENBQUM7SUFFRCxhQUFhO1FBQ1gsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDM0MsQ0FBQztJQUVELGVBQWU7UUFDYixJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsaUJBQWlCLENBQUMsd0JBQXdCLENBQUMsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUM7UUFDMUYsT0FBTyxDQUFVLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsUUFBUSxDQUFDLEVBQUUsR0FBRyxFQUFFO1lBQzFFLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxFQUFFLENBQUM7UUFDN0IsQ0FBQyxDQUFDLENBQUM7UUFFSCx1RUFBdUU7UUFDdkUsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLG1CQUFtQixDQUFDLG9CQUFvQixDQUFDLEVBQUU7WUFDekQsSUFBSSxDQUFDLG1CQUFtQixHQUFHLE9BQU8sQ0FBTSxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUMsYUFBYSxFQUFFLFFBQVEsQ0FBQyxFQUFFLENBQUMsRUFBRSxZQUFZLEVBQUUsRUFBRSxFQUFFO2dCQUNsRyxJQUFJLFlBQVksSUFBSSxZQUFZLENBQUMsUUFBUSxJQUFJLFlBQVksQ0FBQyxrQkFBa0IsRUFBRTtvQkFDNUUsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUM7eUJBQ3JDLElBQUksQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQyxJQUFJLEtBQUssb0JBQW9CLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzt5QkFDeEQsTUFBTSxDQUFDLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLEdBQUcsTUFBTSxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsWUFBWSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztvQkFFN0UsSUFBSSxDQUFDLG1CQUFtQixFQUFFLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztpQkFDNUM7WUFDSCxDQUFDLENBQUMsQ0FBQztTQUNKO0lBQ0gsQ0FBQztJQUVRLFdBQVc7UUFDbEIsS0FBSyxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQ3BCLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxXQUFXLEVBQUUsQ0FBQztJQUMxQyxDQUFDOzttSEFyRFUscUJBQXFCO3VHQUFyQixxQkFBcUIsOE5BN0N0Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBMENUOzRGQUdVLHFCQUFxQjtrQkEvQ2pDLFNBQVM7bUJBQUM7b0JBQ1QsUUFBUSxFQUFFLDZCQUE2QjtvQkFDdkMsUUFBUSxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0EwQ1Q7b0JBQ0QsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07aUJBQ2hEO21JQUtrRCxnQkFBZ0I7c0JBQWhFLFNBQVM7dUJBQUMsa0JBQWtCLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ29tcG9uZW50LFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgVmlld0NoaWxkLFxuICBBZnRlclZpZXdJbml0LFxuICBPbkRlc3Ryb3ksXG4gIFRlbXBsYXRlUmVmLFxuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgVHlwZSxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGaWVsZFR5cGVDb25maWcsIEZvcm1seUNvbmZpZywgRm9ybWx5RmllbGRDb25maWcsIMm1b2JzZXJ2ZSBhcyBvYnNlcnZlIH0gZnJvbSAnQG5neC1mb3JtbHkvY29yZSc7XG5pbXBvcnQgeyBGaWVsZFR5cGUsIEZvcm1seUZpZWxkUHJvcHMgfSBmcm9tICdAbmd4LWZvcm1seS9tYXRlcmlhbC9mb3JtLWZpZWxkJztcbmltcG9ydCB7IENvbXBvbmVudFR5cGUgfSBmcm9tICdAYW5ndWxhci9jZGsvcG9ydGFsJztcbmltcG9ydCB7IE1hdENhbGVuZGFyQ2VsbENsYXNzRnVuY3Rpb24sIE1hdERhdGVwaWNrZXIgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9kYXRlcGlja2VyJztcblxuaW50ZXJmYWNlIERhdGVwaWNrZXJQcm9wcyBleHRlbmRzIEZvcm1seUZpZWxkUHJvcHMge1xuICBkYXRlcGlja2VyT3B0aW9ucz86IFBhcnRpYWw8e1xuICAgIHRvdWNoVWk6IGJvb2xlYW47XG4gICAgb3BlbmVkOiBib29sZWFuO1xuICAgIGRpc2FibGVkOiBib29sZWFuO1xuICAgIHN0YXJ0VmlldzogJ21vbnRoJyB8ICd5ZWFyJyB8ICdtdWx0aS15ZWFyJztcbiAgICBkYXRlcGlja2VyVG9nZ2xlUG9zaXRpb246ICdzdWZmaXgnIHwgJ3ByZWZpeCc7XG4gICAgY2FsZW5kYXJIZWFkZXJDb21wb25lbnQ6IENvbXBvbmVudFR5cGU8YW55PjtcbiAgICBmaWx0ZXI6IChkYXRlOiBhbnkgfCBudWxsKSA9PiBib29sZWFuO1xuICAgIG1pbjogYW55O1xuICAgIG1heDogYW55O1xuICAgIGRhdGVJbnB1dDogKGZpZWxkOiBGaWVsZFR5cGVDb25maWc8RGF0ZXBpY2tlclByb3BzPiwgZXZlbnQ6IGFueSkgPT4gdm9pZDtcbiAgICBkYXRlQ2hhbmdlOiAoZmllbGQ6IEZpZWxkVHlwZUNvbmZpZzxEYXRlcGlja2VyUHJvcHM+LCBldmVudDogYW55KSA9PiB2b2lkO1xuXG4gICAgbW9udGhTZWxlY3RlZDogKGZpZWxkOiBGaWVsZFR5cGVDb25maWc8RGF0ZXBpY2tlclByb3BzPiwgZXZlbnQ6IGFueSwgcGlja2VyOiBNYXREYXRlcGlja2VyPGFueT4pID0+IHZvaWQ7XG4gICAgeWVhclNlbGVjdGVkOiAoZmllbGQ6IEZpZWxkVHlwZUNvbmZpZzxEYXRlcGlja2VyUHJvcHM+LCBldmVudDogYW55LCBwaWNrZXI6IE1hdERhdGVwaWNrZXI8YW55PikgPT4gdm9pZDtcblxuICAgIGRhdGVDbGFzczogTWF0Q2FsZW5kYXJDZWxsQ2xhc3NGdW5jdGlvbjxhbnk+O1xuICAgIHBhbmVsQ2xhc3M6IHN0cmluZyB8IHN0cmluZ1tdO1xuICAgIHN0YXJ0QXQ6IGFueSB8IG51bGw7XG4gIH0+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZvcm1seURhdGVwaWNrZXJGaWVsZENvbmZpZyBleHRlbmRzIEZvcm1seUZpZWxkQ29uZmlnPERhdGVwaWNrZXJQcm9wcz4ge1xuICB0eXBlOiAnZGF0ZXBpY2tlcicgfCBUeXBlPEZvcm1seUZpZWxkRGF0ZXBpY2tlcj47XG59XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2Zvcm1seS1maWVsZC1tYXQtZGF0ZXBpY2tlcicsXG4gIHRlbXBsYXRlOiBgXG4gICAgPGlucHV0XG4gICAgICBtYXRJbnB1dFxuICAgICAgW2lkXT1cImlkXCJcbiAgICAgIFtlcnJvclN0YXRlTWF0Y2hlcl09XCJlcnJvclN0YXRlTWF0Y2hlclwiXG4gICAgICBbZm9ybUNvbnRyb2xdPVwiZm9ybUNvbnRyb2xcIlxuICAgICAgW21hdERhdGVwaWNrZXJdPVwicGlja2VyXCJcbiAgICAgIFttYXREYXRlcGlja2VyRmlsdGVyXT1cInByb3BzLmRhdGVwaWNrZXJPcHRpb25zLmZpbHRlclwiXG4gICAgICBbbWF4XT1cInByb3BzLmRhdGVwaWNrZXJPcHRpb25zLm1heFwiXG4gICAgICBbbWluXT1cInByb3BzLmRhdGVwaWNrZXJPcHRpb25zLm1pblwiXG4gICAgICBbZm9ybWx5QXR0cmlidXRlc109XCJmaWVsZFwiXG4gICAgICBbcGxhY2Vob2xkZXJdPVwicHJvcHMucGxhY2Vob2xkZXJcIlxuICAgICAgW3RhYmluZGV4XT1cInByb3BzLnRhYmluZGV4XCJcbiAgICAgIFtyZWFkb25seV09XCJwcm9wcy5yZWFkb25seVwiXG4gICAgICBbcmVxdWlyZWRdPVwicmVxdWlyZWRcIlxuICAgICAgKGRhdGVJbnB1dCk9XCJwcm9wcy5kYXRlcGlja2VyT3B0aW9ucy5kYXRlSW5wdXQoZmllbGQsICRldmVudClcIlxuICAgICAgKGRhdGVDaGFuZ2UpPVwicHJvcHMuZGF0ZXBpY2tlck9wdGlvbnMuZGF0ZUNoYW5nZShmaWVsZCwgJGV2ZW50KVwiXG4gICAgLz5cbiAgICA8bmctdGVtcGxhdGUgI2RhdGVwaWNrZXJUb2dnbGU+XG4gICAgICA8bWF0LWRhdGVwaWNrZXItdG9nZ2xlXG4gICAgICAgIChjbGljayk9XCJkZXRlY3RDaGFuZ2VzKClcIlxuICAgICAgICBbZGlzYWJsZWRdPVwicHJvcHMuZGlzYWJsZWRcIlxuICAgICAgICBbZm9yXT1cInBpY2tlclwiXG4gICAgICA+PC9tYXQtZGF0ZXBpY2tlci10b2dnbGU+XG4gICAgPC9uZy10ZW1wbGF0ZT5cbiAgICA8bWF0LWRhdGVwaWNrZXJcbiAgICAgICNwaWNrZXJcbiAgICAgIFtjb2xvcl09XCJwcm9wcy5jb2xvclwiXG4gICAgICBbZGF0ZUNsYXNzXT1cInByb3BzLmRhdGVwaWNrZXJPcHRpb25zLmRhdGVDbGFzc1wiXG4gICAgICBbZGlzYWJsZWRdPVwicHJvcHMuZGF0ZXBpY2tlck9wdGlvbnMuZGlzYWJsZWRcIlxuICAgICAgW29wZW5lZF09XCJwcm9wcy5kYXRlcGlja2VyT3B0aW9ucy5vcGVuZWRcIlxuICAgICAgW3BhbmVsQ2xhc3NdPVwicHJvcHMuZGF0ZXBpY2tlck9wdGlvbnMucGFuZWxDbGFzc1wiXG4gICAgICBbc3RhcnRBdF09XCJwcm9wcy5kYXRlcGlja2VyT3B0aW9ucy5zdGFydEF0XCJcbiAgICAgIFtzdGFydFZpZXddPVwicHJvcHMuZGF0ZXBpY2tlck9wdGlvbnMuc3RhcnRWaWV3XCJcbiAgICAgIFt0b3VjaFVpXT1cInByb3BzLmRhdGVwaWNrZXJPcHRpb25zLnRvdWNoVWlcIlxuICAgICAgW2NhbGVuZGFySGVhZGVyQ29tcG9uZW50XT1cInByb3BzLmRhdGVwaWNrZXJPcHRpb25zLmNhbGVuZGFySGVhZGVyQ29tcG9uZW50XCJcbiAgICAgIChtb250aFNlbGVjdGVkKT1cInByb3BzLmRhdGVwaWNrZXJPcHRpb25zLm1vbnRoU2VsZWN0ZWQoZmllbGQsICRldmVudCwgcGlja2VyKVwiXG4gICAgICAoeWVhclNlbGVjdGVkKT1cInByb3BzLmRhdGVwaWNrZXJPcHRpb25zLnllYXJTZWxlY3RlZChmaWVsZCwgJGV2ZW50LCBwaWNrZXIpXCJcbiAgICAgIChvcGVuZWQpPVwicHJvcHMuZGF0ZXBpY2tlck9wdGlvbnMub3BlbmVkID0gdHJ1ZVwiXG4gICAgICAoY2xvc2VkKT1cInByb3BzLmRhdGVwaWNrZXJPcHRpb25zLm9wZW5lZCA9IGZhbHNlXCJcbiAgICA+XG4gICAgPC9tYXQtZGF0ZXBpY2tlcj5cbiAgYCxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG59KVxuZXhwb3J0IGNsYXNzIEZvcm1seUZpZWxkRGF0ZXBpY2tlclxuICBleHRlbmRzIEZpZWxkVHlwZTxGaWVsZFR5cGVDb25maWc8RGF0ZXBpY2tlclByb3BzPj5cbiAgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3lcbntcbiAgQFZpZXdDaGlsZCgnZGF0ZXBpY2tlclRvZ2dsZScsIHsgc3RhdGljOiB0cnVlIH0pIGRhdGVwaWNrZXJUb2dnbGUhOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gIG92ZXJyaWRlIGRlZmF1bHRPcHRpb25zID0ge1xuICAgIHByb3BzOiB7XG4gICAgICBkYXRlcGlja2VyT3B0aW9uczoge1xuICAgICAgICBzdGFydFZpZXc6ICdtb250aCcgYXMgY29uc3QsXG4gICAgICAgIGRhdGVwaWNrZXJUb2dnbGVQb3NpdGlvbjogJ3N1ZmZpeCcgYXMgY29uc3QsXG4gICAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgb3BlbmVkOiBmYWxzZSxcbiAgICAgICAgZGF0ZUlucHV0OiAoKSA9PiB7fSxcbiAgICAgICAgZGF0ZUNoYW5nZTogKCkgPT4ge30sXG4gICAgICAgIG1vbnRoU2VsZWN0ZWQ6ICgpID0+IHt9LFxuICAgICAgICB5ZWFyU2VsZWN0ZWQ6ICgpID0+IHt9LFxuICAgICAgfSxcbiAgICB9LFxuICB9O1xuICBwcml2YXRlIGZpZWxkRXJyb3JzT2JzZXJ2ZXIhOiBSZXR1cm5UeXBlPHR5cGVvZiBvYnNlcnZlPjtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNvbmZpZzogRm9ybWx5Q29uZmlnLCBwcml2YXRlIGNkUmVmOiBDaGFuZ2VEZXRlY3RvclJlZikge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBkZXRlY3RDaGFuZ2VzKCkge1xuICAgIHRoaXMub3B0aW9ucy5kZXRlY3RDaGFuZ2VzPy4odGhpcy5maWVsZCk7XG4gIH1cblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgdGhpcy5wcm9wc1t0aGlzLnByb3BzLmRhdGVwaWNrZXJPcHRpb25zLmRhdGVwaWNrZXJUb2dnbGVQb3NpdGlvbl0gPSB0aGlzLmRhdGVwaWNrZXJUb2dnbGU7XG4gICAgb2JzZXJ2ZTxib29sZWFuPih0aGlzLmZpZWxkLCBbJ3Byb3BzJywgJ2RhdGVwaWNrZXJPcHRpb25zJywgJ29wZW5lZCddLCAoKSA9PiB7XG4gICAgICB0aGlzLmNkUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICB9KTtcblxuICAgIC8vIHRlbXBvcmFyeSBmaXggZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2NvbXBvbmVudHMvaXNzdWVzLzE2NzYxXG4gICAgaWYgKHRoaXMuY29uZmlnLmdldFZhbGlkYXRvck1lc3NhZ2UoJ21hdERhdGVwaWNrZXJQYXJzZScpKSB7XG4gICAgICB0aGlzLmZpZWxkRXJyb3JzT2JzZXJ2ZXIgPSBvYnNlcnZlPGFueT4odGhpcy5maWVsZCwgWydmb3JtQ29udHJvbCcsICdlcnJvcnMnXSwgKHsgY3VycmVudFZhbHVlIH0pID0+IHtcbiAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSAmJiBjdXJyZW50VmFsdWUucmVxdWlyZWQgJiYgY3VycmVudFZhbHVlLm1hdERhdGVwaWNrZXJQYXJzZSkge1xuICAgICAgICAgIGNvbnN0IGVycm9ycyA9IE9iamVjdC5rZXlzKGN1cnJlbnRWYWx1ZSlcbiAgICAgICAgICAgIC5zb3J0KChwcm9wKSA9PiAocHJvcCA9PT0gJ21hdERhdGVwaWNrZXJQYXJzZScgPyAtMSA6IDApKVxuICAgICAgICAgICAgLnJlZHVjZSgoZXJyb3JzLCBwcm9wKSA9PiAoeyAuLi5lcnJvcnMsIFtwcm9wXTogY3VycmVudFZhbHVlW3Byb3BdIH0pLCB7fSk7XG5cbiAgICAgICAgICB0aGlzLmZpZWxkRXJyb3JzT2JzZXJ2ZXI/LnNldFZhbHVlKGVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIG92ZXJyaWRlIG5nT25EZXN0cm95KCkge1xuICAgIHN1cGVyLm5nT25EZXN0cm95KCk7XG4gICAgdGhpcy5maWVsZEVycm9yc09ic2VydmVyPy51bnN1YnNjcmliZSgpO1xuICB9XG59XG4iXX0=